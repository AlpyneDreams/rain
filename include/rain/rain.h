#pragma once

#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <cstddef>

#include "impl/config.h"
#include "impl/type.h"

namespace rain
{
    /** Extend this class to enable RTTI generation for subclasses. */
    struct Reflect {};

    /** The name of type T **/
    template <typename T>
    constexpr std::string_view TypeName = internal::GetTypeName<T>();

    /** A unique type hash for type T **/
    template <typename T>
    constexpr Hash TypeHash = internal::GetTypeHash<T>();

    /** Returns an ordered index for type T **/
    template <typename T>
    const inline Hash TypeIndex() noexcept { return internal::GetTypeIndex<T>(); }

    /** Type info as returned by TypeID<T>() **/
    struct Type final
    {
        Hash index;
        Hash hash;
        std::string_view name;

        template <typename T, typename Plain = internal::PlainType<T>>
        constexpr Type(std::in_place_type_t<T>) noexcept
          : index {TypeIndex<Plain>()},
            hash  {TypeHash<Plain>},
            name  {TypeName<Plain>}
        {}
    };

    
    /** Get type info for type T **/
    template <typename T>
    const Type TypeID() noexcept {
        using Plain = internal::PlainType<T>;
        if constexpr (std::is_same_v<T, Plain>) {
            static Type instance {std::in_place_type<T>};
            return instance;
        } else {
            return TypeID<Plain>();
        }
    }


    template <typename T>
    struct Registry
    {
        static inline T& Register(T&& c) {
            registry.insert({ c.type.hash, c });
            return c;
        }

        template <typename U>
        static inline T* Get() {
            return Get(TypeHash<U>);
        }

        static inline T* Get(Hash hash) {
            return registry.contains(hash) ? &registry.at(hash) : nullptr;
        }

        static inline T* Get(Type type) {
            return Get(type.hash);
        }

        static inline std::unordered_map<Hash, T> registry;
    };

    struct Field
    {
        const char* name;
        const char* displayName;
        Type type = TypeID<std::nullptr_t>();
        size_t offset;

        template <typename T>
        T* GetPointer(void* obj) const {
            return reinterpret_cast<T*>((char*)obj + offset);
        }

        template <typename T>
        T& Get(void* obj) const {
            return *GetPointer<T>(obj);
        }
    };

    struct Class : Registry<Class>
    {
        const char* name;
        const char* displayName;
        Type type = TypeID<std::nullptr_t>();
        size_t size;
        std::vector<Field> fields;
    };

    struct Enum : Registry<Enum>
    {
        const char* name;
        const char* displayName;
        Type type = TypeID<std::nullptr_t>();
        size_t size;
        Type underlyingType = TypeID<std::nullptr_t>();
        bool scoped = true;
        std::map<std::string, std::uintmax_t> values;
        std::map<std::uintmax_t, std::string> names;

        // TODO: display names, preserve declaration order, flags

        // Follows enum's integer order
        auto begin() const { return names.begin(); }
        auto end() const { return names.end(); }

        template <typename E>
        static std::string Name(auto value) {
            return Enum::Get<E>()->GetName(value);
        }

        // Returns the largest possible value of the given enum
        template <typename E>
        static E Max() {
            return E(Enum::Get<E>()->names.rbegin()->first);
        }

        std::string GetName(auto value) const {
            return names.at(value);
        }

        auto GetValue(std::string& name) const {
            return values.at(name);
        }
    };
}

// This namespace contains all autogenerated RTTI data.
namespace rain::rtti
{
    template <class T>
    Class ClassDef;

    template <class T>
    Enum EnumDef;
}
