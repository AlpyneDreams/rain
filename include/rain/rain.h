#pragma once

#include "impl/config.h"

#include <type_traits>
#include <typeindex>
#include <algorithm>
#include <string>
#include <utility>
#include <vector>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <cstddef>
#include <iterator>
#include <ranges>

#include "impl/type.h"

/** TODO:
 *  - Configuration, meson setup
 *  - constexpr TypeIndex if possible
 *  - Should everything be accessed by methods or is raw data fine?
 *  - Probably best to model desired API before implementing
 *      - e.g. Simplify rain::Class::Get<Component>()->GetDerivedClasses()
 *  - Ditch designated initializer syntax
 *      - base class Object for Enum, Field, Class with name/displayName/type/size
 *  - Potentially reflect all classes by default
 *  - Include size in Type?
 *  - MSVC testing
 *  - Exceptions rather than returning nullptr?
 *  - Lowercase member functions?
 *  - Sizes and offsets determined by libclang and not Python?
 *  - Fancy transform views for e.g. GetBaseClasses
 *      - Returning 'bases | std::views::transform' would work but annoys clang
 *        because it doesn't understand gcc's headers.
 */

namespace rain
{
    /** Extend this class to enable RTTI generation for subclasses. */
    struct Reflect {};

    /** The name of type T **/
    template <typename T>
    constexpr std::string_view TypeName = internal::GetTypeName<T>();

    /** A unique type hash for type T **/
    template <typename T>
    constexpr Hash TypeHash = internal::GetTypeHash<T>();

    /** Type info as returned by TypeID<T> **/
    struct Type final
    {
        Hash hash;
        std::string_view name;

        template <typename T, typename Plain = internal::PlainType<T>>
        constexpr Type(std::in_place_type_t<T>) noexcept
          : hash {TypeHash<Plain>},
            name {TypeName<Plain>}
        {}

        constexpr Type(const Type& type) noexcept
          : hash {type.hash},
            name {type.name}
        {}

        // Null Type (Default Constructor)
        constexpr Type() noexcept
          : hash {TypeHash<std::nullptr_t>},
            name {TypeName<std::nullptr_t>}
        {}

        constexpr operator bool() const {
            return hash != TypeHash<std::nullptr_t>;
        }

        constexpr auto operator <=>(const Type& rhs) const { return hash <=> rhs.hash; }
    };

    template <typename T>
    constexpr Type TypeID = Type(std::in_place_type<internal::PlainType<T>>);


    /** Base class for RTTI registries: Class, Enum, etc. **/
    template <typename T>
    struct Registry
    {
        // Called by autogenerated RTTI code.
        static inline T& Register(T&& c) {
            registry.insert({ c.type.hash, c });
            return c;
        }

        template <typename U>
        static inline T* Get() {
            return Get(TypeHash<U>);
        }

        static inline T* Get(Hash hash) {
            return registry.contains(hash) ? &registry.at(hash) : nullptr;
        }

        static inline T* Get(Type type) {
            return Get(type.hash);
        }

        static inline auto GetAll(const auto& hashes) {
            std::unordered_set<T*> items;
            for (Hash hash : hashes)
                items.insert(Get(hash));
            return items;
        }
        
        static inline std::unordered_map<Hash, T> registry;
    };

    enum class Access {
        None, Public, Protected, Private
    };

    /** RTTI data for a field in a struct or class. **/
    struct Field
    {
        const char* name;
        const char* displayName;
        Type type;
        size_t offset;

        template <typename T>
        T* GetPointer(void* obj) const {
            return reinterpret_cast<T*>((char*)obj + offset);
        }

        template <typename T>
        T& Get(void* obj) const {
            return *GetPointer<T>(obj);
        }
    };

    /** RTTI data for a class or struct. **/
    struct Class : Registry<Class>
    {
        const char* name;
        const char* displayName;
        Type type;
        size_t size;
        std::vector<Field> fields;

        struct Relationship {
            Access access;
            bool isVirtual;
        };

        //std::unordered_map<Hash, Relationship> bases;
        std::unordered_set<Hash> bases;
        std::unordered_set<Hash> derived;

        // TODO: Return some kind of fancy transform views like std::views::transform
        // without agitating clang
        
        inline const auto GetBaseClasses() const {
            return GetAll(bases);
            //return bases | std::views::transform([&](const Hash h) { return Get(h); });
        }
        inline const auto GetDerivedClasses() const {
            return GetAll(derived);
            //return derived | std::views::transform([&](const Hash h) { return Get(h); });
        }

        // Behaves the same as std::is_base_of_v
        template <typename T>
        inline bool DerivedFrom() const {
            // Same type => true
            if (type.hash == TypeHash<T>)
                return true;
            
            //for (auto& [hash, relationship] : bases) {
            for (Hash hash : bases) {
                // Direct base
                if (hash == TypeHash<T>)
                    return true;
                
                // Inherited base (recurse)
                Class* base = Class::Get(hash);
                if (base && base->DerivedFrom<T>())
                    return true;
            }
            return false;
        }
    };

    /** RTTI data for an enum. **/
    struct Enum : Registry<Enum>
    {
        const char* name;
        const char* displayName;
        Type type;
        size_t size;
        Type underlyingType;
        bool scoped = true;
        std::map<std::string, std::uintmax_t> values;
        std::map<std::uintmax_t, std::string> names;

        // TODO: display names, preserve declaration order, flags

        // Follows enum's integer order
        auto begin() const { return names.begin(); }
        auto end() const { return names.end(); }

        template <typename E>
        static std::string Name(auto value) {
            return Enum::Get<E>()->GetName(value);
        }

        // Returns the largest possible value of the given enum
        template <typename E>
        static E Max() {
            return E(Enum::Get<E>()->names.rbegin()->first);
        }

        std::string GetName(auto value) const {
            return names.at(value);
        }

        auto GetValue(std::string& valueName) const {
            return values.at(valueName);
        }
    };
}

// This namespace contains all autogenerated RTTI data.
namespace rain::rtti
{
    template <class T>
    Class ClassDef;

    template <class T>
    Enum EnumDef;
}
